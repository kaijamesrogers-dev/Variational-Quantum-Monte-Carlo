import numpy as np
from task_3_1 import lcg_random
import matplotlib.pyplot as plt

SEED = 42
THETA_INITIAL = 1.0
q_1 = np.array([0.7, 0.0, 0.0])  # position of proton 1
q_2 = np.array([-0.7, 0.0, 0.0])  # position of proton 2
q = np.array([q_1, q_2])

#new wavefunction for 2 protons in 3D
def psi_h2(x_a, y_a, z_a, x_b, y_b, z_b, theta1, theta2, theta3, q1, q2):
    """
    Hydrogen molecule trial wavefunction ω(r1, r2; θ1, θ2, θ3)
    from eq. (18) of the project script.
    """
    r1 = np.array([x_a, y_a, z_a])
    r2 = np.array([x_b, y_b, z_b])

    # distances to nuclei
    r1_q1 = np.linalg.norm(r1 - q1)
    r1_q2 = np.linalg.norm(r1 - q2)
    r2_q1 = np.linalg.norm(r2 - q1)
    r2_q2 = np.linalg.norm(r2 - q2)

    # electron–electron distance
    r12 = np.linalg.norm(r1 - r2)

    # Slater-like part (the bracket in eq. 18)
    slater = (
        np.exp(-theta1 * (r1_q1 + r2_q2)) +
        np.exp(-theta1 * (r1_q2 + r2_q1))
    )

    # Jastrow factor exp(-θ2 / (1 + θ3 r12))
    jastrow = np.exp(-theta2 / (1.0 + theta3 * r12))

    return slater * jastrow

#new probability density function for 2 protons in 3D
def pdf_xyz(x_a, y_a, z_a, x_b, y_b, z_b, theta1, theta2, theta3, q1, q2):
    psi = psi_h2(x_a, y_a, z_a, x_b, y_b, z_b, theta1, theta2, theta3, q1, q2)
    return psi**2   # |ω|^2

# new metropolis function for 2 protons in 3D
def metropolis_2protons(step_size, pdf, iterations, theta1, theta2, theta3, q_1, q_2, seed=SEED):
    """
    3D Metropolis–Hastings sampler.

    Returns:
        samples: array of shape (iterations, 6)
                 each row is [x_a, y_a, z_a, x_b, y_b, z_b]
    """
    # 6 uniforms for initial point + (6 for proposal + 1 for accept) per step
    n_uniform = 6 + 7 * (iterations - 1)
    u = lcg_random(seed, n_uniform)
    idx = 0

    samples = np.zeros((iterations, 6))

    # Initial point in [-1, 1]^3 for both protons
    samples[0, :3] = (u[idx:idx+3] - 0.5) * 2.0
    samples[0, 3:] = (u[idx+3:idx+6] - 0.5) * 2.0
    idx += 6

    for i in range(1, iterations):
        x_a_current, y_a_current, z_a_current = samples[i-1, :3]
        x_b_current, y_b_current, z_b_current = samples[i-1, 3:]

        # Proposal step in each coordinate
        u_step = u[idx:idx+6]
        idx += 6
        step_vec = step_size * (2 * u_step - 1)  # each in [-step_size, step_size]

        x_a_prop = x_a_current + step_vec[0]
        y_a_prop = y_a_current + step_vec[1]
        z_a_prop = z_a_current + step_vec[2]
        x_b_prop = x_b_current + step_vec[3]
        y_b_prop = y_b_current + step_vec[4]
        z_b_prop = z_b_current + step_vec[5]

        # Acceptance uniform
        u_accept = u[idx]
        idx += 1

        p_current = pdf(x_a_current, y_a_current, z_a_current, x_b_current, y_b_current, z_b_current, theta1, theta2, theta3, q_1, q_2)
        p_prop    = pdf(x_a_prop,    y_a_prop,    z_a_prop,    x_b_prop,    y_b_prop,    z_b_prop,    theta1, theta2, theta3, q_1, q_2)

        if p_current <= 0:
            alpha = 1.0    # if current state is impossible, move
        else:
            alpha = min(1.0, p_prop / p_current)

        if u_accept < alpha:
            samples[i, :] = [x_a_prop, y_a_prop, z_a_prop, x_b_prop, y_b_prop, z_b_prop]
        else:
            samples[i, :] = [x_a_current, y_a_current, z_a_current, x_b_current, y_b_current, z_b_current]

    return samples

#samples_2protons = metropolis_2protons(0.5, pdf_xyz, 100000, THETA_INITIAL, THETA_INITIAL, THETA_INITIAL, q_1, q_2, SEED)

def w2_2nd_2_protons_xa(f, x_a, y_a, z_a, x_b, y_b, z_b, h, *f_args):
    return (f(x_a + h, y_a, z_a, x_b, y_b, z_b, *f_args) - 2*f(x_a, y_a, z_a, x_b, y_b, z_b, *f_args) + f(x_a - h, y_a, z_a, x_b, y_b, z_b, *f_args)) / h**2
    
def w2_2nd_2_protons_ya(f, x_a, y_a, z_a, x_b, y_b, z_b, h, *f_args):
    return (f(x_a, y_a + h, z_a, x_b, y_b, z_b, *f_args) - 2*f(x_a, y_a, z_a, x_b, y_b, z_b, *f_args) + f(x_a, y_a - h, z_a, x_b, y_b, z_b, *f_args)) / h**2

def w2_2nd_2_protons_za(f, x_a, y_a, z_a, x_b, y_b, z_b, h, *f_args):
    return (f(x_a, y_a, z_a + h, x_b, y_b, z_b, *f_args) - 2*f(x_a, y_a, z_a, x_b, y_b, z_b, *f_args) + f(x_a, y_a, z_a - h, x_b, y_b, z_b, *f_args)) / h**2

def w2_2nd_2_protons_xb(f, x_a, y_a, z_a, x_b, y_b, z_b, h, *f_args):
    return (f(x_a, y_a, z_a, x_b + h, y_b, z_b, *f_args) - 2*f(x_a, y_a, z_a, x_b, y_b, z_b, *f_args) + f(x_a, y_a, z_a, x_b - h, y_b, z_b, *f_args)) / h**2   

def w2_2nd_2_protons_yb(f, x_a, y_a, z_a, x_b, y_b, z_b, h, *f_args):
    return (f(x_a, y_a, z_a, x_b, y_b + h, z_b, *f_args) - 2*f(x_a, y_a, z_a, x_b, y_b, z_b, *f_args) + f(x_a, y_a, z_a, x_b, y_b - h, z_b, *f_args)) / h**2

def w2_2nd_2_protons_zb(f, x_a, y_a, z_a, x_b, y_b, z_b, h, *f_args):
    return (f(x_a, y_a, z_a, x_b, y_b, z_b + h, *f_args) - 2*f(x_a, y_a, z_a, x_b, y_b, z_b, *f_args) + f(x_a, y_a, z_a, x_b, y_b, z_b - h, *f_args)) / h**2

def energy(samples, theta1, theta2, theta3, q):
    N = samples.shape[0]
    E = 0.0

    for i in range(N):
        x_a, y_a, z_a, x_b, y_b, z_b = samples[i, :]

        r1 = np.array([x_a, y_a, z_a])
        r2 = np.array([x_b, y_b, z_b])

        r1_q1 = np.linalg.norm(r1 - q[0])
        r1_q2 = np.linalg.norm(r1 - q[1])
        r2_q1 = np.linalg.norm(r2 - q[0])
        r2_q2 = np.linalg.norm(r2 - q[1])
        q12 = np.linalg.norm(q[0] - q[1])
        r12 = np.linalg.norm(r1 - r2)
    
 
        # Kinetic energy term (using finite difference approximation)
        h = 1e-4
        psi = psi_h2(x_a, y_a, z_a, x_b, y_b, z_b, theta1, theta2, theta3, q[0], q[1])

        El = (- 1 / (2 * psi) * (
            w2_2nd_2_protons_xa(psi_h2, x_a, y_a, z_a, x_b, y_b, z_b, h, theta1, theta2, theta3, q[0], q[1]) +
            w2_2nd_2_protons_ya(psi_h2, x_a, y_a, z_a, x_b, y_b, z_b, h, theta1, theta2, theta3, q[0], q[1]) +
            w2_2nd_2_protons_za(psi_h2, x_a, y_a, z_a, x_b, y_b, z_b, h, theta1, theta2, theta3, q[0], q[1]) +
            w2_2nd_2_protons_xb(psi_h2, x_a, y_a, z_a, x_b, y_b, z_b, h, theta1, theta2, theta3, q[0], q[1]) +
            w2_2nd_2_protons_yb(psi_h2, x_a, y_a, z_a, x_b, y_b, z_b, h, theta1, theta2, theta3, q[0], q[1]) +
            w2_2nd_2_protons_zb(psi_h2, x_a, y_a, z_a, x_b, y_b, z_b, h, theta1, theta2, theta3, q[0], q[1])) -
            1 / r1_q1 - 1 / r1_q2 - 1 / r2_q1 - 1 / r2_q2 + 1 / q12 + 1 / r12)
        
        E += El

    return E / N

#new minimisation function for 2 protons
def monte_carlo_minimisation_2protons(step_size, pdf, iterations, T,
                                      theta=THETA_INITIAL, seed=SEED):
    # Draw ONE chain at the start, using the initial theta
    theta1 = theta
    theta2 = theta
    theta3 = theta

    samples = metropolis_2protons(step_size, pdf, 3000,
                                  theta1, theta2, theta3, q_1, q_2, seed)

    E = energy(samples, theta1, theta2, theta3, q)

    # Use different random numbers just for parameter proposals
    u = lcg_random(seed + 1, 3 * iterations)
    n = 0

    for i in range(iterations):
        du1 = 2 * u[3*i    ] - 1
        du2 = 2 * u[3*i + 1] - 1
        du3 = 2 * u[3*i + 2] - 1

        theta1_dash = theta1 + step_size * du1
        theta2_dash = theta2 + step_size * du2
        theta3_dash = theta3 + step_size * du3

        # After proposing theta1_dash, theta2_dash, theta3_dash
        if not (0.0 < theta1_dash < 5.0 and
                0.0 < theta2_dash < 5.0 and
                0.0 <= theta3_dash < 5.0):
            # Reject this move: just continue to next iteration
            continue

        # REUSE the same samples here
        E_dash = energy(samples, theta1_dash, theta2_dash, theta3_dash, q)

        delta_E = E_dash - E

        if delta_E > 0:
            alpha = np.exp(- delta_E / T)
            rand = np.random.rand()
            if rand < alpha:
                theta1, theta2, theta3 = theta1_dash, theta2_dash, theta3_dash
                E = E_dash
        else:
            theta1, theta2, theta3 = theta1_dash, theta2_dash, theta3_dash
            E = E_dash

        n += 1
        if n == 10:
            T *= 0.8
            n = 0

    return theta1, theta2, theta3


theta1,theta2, theta3 = monte_carlo_minimisation_2protons(0.5, pdf_xyz, 100, 1.0, THETA_INITIAL, SEED)
print("Optimized theta values for H2 molecule:", theta1, theta2, theta3)

energy_estimate = energy(metropolis_2protons(0.5, pdf_xyz, 10000,
                                  theta1, theta2, theta3, q_1, q_2, SEED), theta1, theta2, theta3, q)
print("Estimated Energy Expectation Value for H2 molecule:", energy_estimate)
