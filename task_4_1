import numpy as np
from task_3_1 import lcg_random, energy
import matplotlib.pyplot as plt

SEED = 42
THETA_INITIAL = 1.0
q_1 = [1.0, 0.0, 0.0]  # position of proton 1
q_2 = [-1.0, 0.0, 0.0]  # position of proton 2

#new wavefunction for 2 protons in 3D
def psi_h2(x_a, y_a, z_a, x_b, y_b, z_b, theta1, theta2, theta3, q1, q2):
    """
    Hydrogen molecule trial wavefunction ω(r1, r2; θ1, θ2, θ3)
    from eq. (18) of the project script.
    """
    r1 = np.array([x_a, y_a, z_a])
    r2 = np.array([x_b, y_b, z_b])

    # distances to nuclei
    r1_q1 = np.linalg.norm(r1 - q1)
    r1_q2 = np.linalg.norm(r1 - q2)
    r2_q1 = np.linalg.norm(r2 - q1)
    r2_q2 = np.linalg.norm(r2 - q2)

    # electron–electron distance
    r12 = np.linalg.norm(r1 - r2)

    # Slater-like part (the bracket in eq. 18)
    slater = (
        np.exp(-theta1 * (r1_q1 + r2_q2)) +
        np.exp(-theta1 * (r1_q2 + r2_q1))
    )

    # Jastrow factor exp(-θ2 / (1 + θ3 r12))
    jastrow = np.exp(-theta2 / (1.0 + theta3 * r12))

    return slater * jastrow

#new probability density function for 2 protons in 3D
def pdf_xyz(x_a, y_a, z_a, x_b, y_b, z_b, theta1, theta2, theta3, q1, q2):
    psi = psi_h2(x_a, y_a, z_a, x_b, y_b, z_b, theta1, theta2, theta3, q1, q2)
    return psi**2   # |ω|^2

# new metropolis function for 2 protons in 3D
def metropolis_2protons(step_size, pdf, iterations, theta, seed=SEED):
    """
    3D Metropolis–Hastings sampler.

    Returns:
        samples: array of shape (iterations, 6)
                 each row is [x_a, y_a, z_a, x_b, y_b, z_b]
    """
    # 6 uniforms for initial point + (6 for proposal + 1 for accept) per step
    n_uniform = 6 + 7 * (iterations - 1)
    u = lcg_random(seed, n_uniform)
    idx = 0

    samples = np.zeros((iterations, 6))

    # Initial point in [-1, 1]^3 for both protons
    samples[0, :3] = (u[idx:idx+3] - 0.5) * 2.0
    samples[0, 3:] = (u[idx+3:idx+6] - 0.5) * 2.0
    idx += 6

    for i in range(1, iterations):
        x_a_current, y_a_current, z_a_current = samples[i-1, :3]
        x_b_current, y_b_current, z_b_current = samples[i-1, 3:]

        # Proposal step in each coordinate
        u_step = u[idx:idx+6]
        idx += 6
        step_vec = step_size * (2 * u_step - 1)  # each in [-step_size, step_size]

        x_a_prop = x_a_current + step_vec[0]
        y_a_prop = y_a_current + step_vec[1]
        z_a_prop = z_a_current + step_vec[2]
        x_b_prop = x_b_current + step_vec[3]
        y_b_prop = y_b_current + step_vec[4]
        z_b_prop = z_b_current + step_vec[5]

        # Acceptance uniform
        u_accept = u[idx]
        idx += 1

        p_current = pdf(x_a_current, y_a_current, z_a_current, x_b_current, y_b_current, z_b_current, theta)
        p_prop    = pdf(x_a_prop,    y_a_prop,    z_a_prop,    x_b_prop,    y_b_prop,    z_b_prop,    theta)

        if p_current <= 0:
            alpha = 1.0    # if current state is impossible, move
        else:
            alpha = min(1.0, p_prop / p_current)

        if u_accept < alpha:
            samples[i, :] = [x_a_prop, y_a_prop, z_a_prop, x_b_prop, y_b_prop, z_b_prop]
        else:
            samples[i, :] = [x_a_current, y_a_current, z_a_current, x_b_current, y_b_current, z_b_current]

    return samples

#new minimisation function for 2 protons
def monte_carlo_minimisation_2protons(step_size, pdf, iterations, T, theta = THETA_INITIAL, seed=SEED):
    u = lcg_random(seed, 2 * iterations)
    n = 0
    samples = metropolis_2protons(step_size, pdf, iterations * 30, theta, seed)
    E = energy(samples, theta)
    for i in range(iterations):
        theta_dash = theta + step_size * (2 * u[i] - 1)
        samples_dash = metropolis_2protons(step_size, pdf, iterations * 30, theta_dash, seed)
        E_dash = energy(samples_dash, theta_dash)

        delta_E = E_dash - E

        if delta_E > 0:
            alpha = np.exp(- delta_E / T)
            random = u[2 * i]
            if random < alpha:
                theta = theta_dash
                E = E_dash
        else:
            theta = theta_dash
            E = E_dash

        n += 1
        if n == 10:
            T = T * 0.8
            n = 0

    return theta


